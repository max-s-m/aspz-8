# Завдання 1

## Умова:

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## [Програмний код](1.c)

## Опис:

Викликання write(fd, buffer, nbytes) може повернути не nbytes, може і без помилки, що називається
частковим записом (partial write). На приклад при записі у неблокуючий (означає, що операції
введення/виведення не блокують виконання програми) дескриптор pipe з буфера, який є більшим за
буфер pipe, що мій приклад і демонструє шляхом створення pipe та додавання прапорця O_NONBLOCK
для задання дескрипторя як неблокуючого.

## Результат виконання:

```
max@aspz:~/c/8 $ gcc -Wall 1.c -o 1
max@aspz:~/c/8 $ ./1
Requested: 100000, Written: 65536
```

# Завдання 2

## Умова:

Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## [Програмний код](2.c)

## Опис:

Написано програму для тестування випадку з умови та відповіді на питання. У ній створено
дескриптор до файлу, у який записується послідовність даних, надана у завданні.
Покажчик файлу після lseek(fd, 3, SEEK_SET) встановиться перед 3-м байтом (індексація з нуля).
Послідовність байтів у файлі: 4, 5, 2, [2], 3, 3, 7, 9, 1, 5 ([ ] - позиція після lseek).
Виклик read(fd, &buff, 4) прочитає 4 байти, починаючи з цієї позиції.
Таким чином буфер buff буде містити: 2, 3, 3, 7, що і видно у результаті виконання.

## Результат виконання:

```
max@aspz:~/c/8 $ gcc -Wall 2.c -o 2
max@aspz:~/c/8 $ ./2
Read 4 B. Buff: 2 3 3 7
max@aspz:~/c/8 $
```

# Завдання 3

## Умова:

Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
- Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
- Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## [Програмний код](3.c)

## Опис:

Створено програму для тестування швидкості та правильності роботи quick sort (qsort()).
Сортування тестується на дев'яти випадках: три види початкових масивів (кожний створюється
відповідною функцією fill_sorted/reverse/rand) зростаючий(сортований)/спадаючий/рандомний,
і кожний з трьома розмірами: сто тисяч, пів мільйона, мальйон. Функція compare написана для
порівняння масивів у qsort. За результатами виконання видно, що найгірший випадок для швидкого
сорту є випадковий масив, другий за складністю - спадаючий, а найлегший - вже відсортований.
Як і очікувалось також залежність від розміру: більший - довше. Ф-ція sorted перевіряє чи
масив сортований та передбачувано повідомляє що бібліотечна ф-ція працює.

## Результат виконання:

```
max@aspz:~/c/8 $ gcc -Wall 3.c -o 3
max@aspz:~/c/8 $ ./3
Sorted,   n = 100000,   time = 0.000 sec,   sorted: yes
Reversed,   n = 100000,   time = 0.000 sec,   sorted: yes
Random,   n = 100000,   time = 0.008 sec,   sorted: yes
Sorted,   n = 500000,   time = 0.023 sec,   sorted: yes
Reversed,   n = 500000,   time = 0.016 sec,   sorted: yes
Random,   n = 500000,   time = 0.086 sec,   sorted: yes
Sorted,   n = 1000000,   time = 0.016 sec,   sorted: yes
Reversed,   n = 1000000,   time = 0.023 sec,   sorted: yes
Random,   n = 1000000,   time = 0.203 sec,   sorted: yes
max@aspz:~/c/8 $
```

# Завдання 4

## Умова:

Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?


## [Програмний код](4.c)

## Опис:

Переписано та запущено надану програму з fork() та виведенням отриманого ID процесу (PID).
Припускаючи, що fork() вийшов (перевірку все одно додано), у батьківському процесі fork
повертає PID (Process ID) дочірнього процесу (додатній int).У дитячому процесі fork повертає 0.
Обидва процеси виконують printf, але батьківський виконує його першим у моєму випадку, що
не завжди і не всюди так. Обидва процеси, при вдалій роботі fork, працюють у процесорі одночасно,
але, на приклад у моїй системі, система віддає пріоритет першості виконання батьківським процесам.

## Результат виконання:

```
max@aspz:~/c/8 $ gcc -Wall 4.c -o 4
max@aspz:~/c/8 $ ./4
(Parent proc) Child ID: 3389
(Child proc) PID: 0
max@aspz:~/c/8 $
```

# Завдання 5

## Умова:

Реалізуйте команду, яка виводить зсуви (offset) усіх відкритих файлів у процесі, який ви не створювали.

## [Програмний код](5.c)

## Опис:

Написано програму, у якій виводяться зсуви (offset - поточна позиція у файлі) відкритих файлів у процесі,
який я не створював. За такий процес обрано один з PID, отриманих при виконанні pgrep kate, що
отримує процеси стандартного файлового редактора Kate для KDE Plasma (граф. інтерфейс для FreeBSD).
Для порівняння виводу програми також прописано procstat -f 3009 (PID) обраного процесу, вивід якого
також показує офсети вікритих файлів.

## Результат виконання:

```
max@aspz:~/c/8 $ pgrep kate
3009
2861
3789
3475
3189
2809
ax@aspz:~/c/8 $ sudo procstat -f 3009
  PID COMM                FD T V FLAGS    REF  OFFSET PRO NAME
 3009 kate              text v r r-------   -       - -   /usr/local/bin/kate
 3009 kate               cwd v d r-------   -       - -   /home/max/c/8
 3009 kate              root v d r-------   -       - -   /
 3009 kate                 0 p - rw------   1       0 -   -
 3009 kate                 1 v c -w------  31       0 -   /dev/null
 3009 kate                 2 v r -w------  35  120653 -   -
 3009 kate                 3 s - rw---n--   1       0 UDS 0 0 /tmp/.X11-unix/X0
 3009 kate                 4 E - rw---n--   1       0 -   -
 3009 kate                 5 E - rw---n--   1       0 -   -
 3009 kate                 6 s - rw------   1       0 UDS 0 0 /tmp/.ICE-unix/953
 3009 kate                 7 E - rw---n--   1       0 -   -
 3009 kate                 8 s - rw---n--   1       0 UDS 0 0 /tmp/dbus-VQ8kVSXBuQ
 3009 kate                89 v r r-------  11       0 -   /home/max/.local/share/baloo/index
max@aspz:~/c/8 $ sudo ./5 3009
File offsets for PID 3009:
  fd 0: 0
  fd 1: 0
  fd 2: 120653
  fd 3: (Didn't read offset)
  fd 4: (Didn't read offset)
  fd 5: (Didn't read offset)
  fd 6: (Didn't read offset)
  fd 7: (Didn't read offset)
  fd 8: (Didn't read offset)
  fd 89: 0
max@aspz:~/c/8 $
```
